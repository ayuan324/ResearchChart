# è¡¨æ ¼è§£æé—®é¢˜åˆ†æ

## å½“å‰è§£æé€»è¾‘ï¼ˆ`/api/ingest/route.ts`ï¼‰

### 1. è¡¨æ ¼æå–å‡½æ•° `extractPipeTables()`

```typescript
function extractPipeTables(md: string): string[] {
  const lines = md.split(/\r?\n/);
  const tables: string[] = [];
  let buf: string[] = [];
  let inTable = false;

  for (const line of lines) {
    const isPipe = /\|/.test(line);  // âš ï¸ é—®é¢˜1ï¼šåªè¦æœ‰ | å°±è®¤ä¸ºæ˜¯è¡¨æ ¼è¡Œ
    if (isPipe) {
      inTable = true;
      buf.push(line);
    } else {
      if (inTable) {
        // åªæ£€æŸ¥ç¬¬äºŒè¡Œæ˜¯å¦æœ‰åˆ†éš”ç¬¦
        if (buf.length >= 2 && /\|\s*-{2,}\s*\|/.test(buf[1])) {
          tables.push(buf.join("\n"));
        }
        buf = [];
        inTable = false;
      }
    }
  }

  if (inTable && buf.length >= 2 && /\|\s*-{2,}\s*\|/.test(buf[1])) {
    tables.push(buf.join("\n"));
  }

  return tables;
}
```

### ğŸ› é—®é¢˜åˆ†æ

#### é—®é¢˜ 1: è¿‡åº¦å®½æ¾çš„è¡¨æ ¼è¯†åˆ«
- **ç°è±¡**: åªè¦ä¸€è¡ŒåŒ…å« `|` å­—ç¬¦ï¼Œå°±è¢«è®¤ä¸ºæ˜¯è¡¨æ ¼è¡Œ
- **åæœ**: ä¼šå°†ä»¥ä¸‹å†…å®¹è¯¯è¯†åˆ«ä¸ºè¡¨æ ¼ï¼š
  - ä»£ç å—ä¸­çš„ç®¡é“ç¬¦ï¼š`command | grep pattern`
  - æ•°å­¦å…¬å¼ï¼š`P(A|B) = 0.5`
  - æ™®é€šæ–‡æœ¬ï¼š`é€‰é¡¹A | é€‰é¡¹B`
  - å¼•ç”¨å—ä¸­çš„ç«–çº¿

#### é—®é¢˜ 2: ç¼ºå°‘è¡¨æ ¼ç»“æ„éªŒè¯
- **ç°è±¡**: åªéªŒè¯ç¬¬äºŒè¡Œæ˜¯å¦æ˜¯åˆ†éš”ç¬¦ï¼Œä¸éªŒè¯æ•´ä½“ç»“æ„
- **åæœ**:
  - ä¸æ£€æŸ¥åˆ—æ•°æ˜¯å¦ä¸€è‡´
  - ä¸æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„æ•°æ®è¡Œ
  - ä¸æ£€æŸ¥è¡¨å¤´æ˜¯å¦åˆç†

#### é—®é¢˜ 3: ç»“è®ºè§£æä¸ç¨³å®š
- **ç°è±¡**: `table_conclusions` è¿”å›çš„å¯èƒ½æ˜¯åµŒå¥—æ•°ç»„ï¼Œä¹Ÿå¯èƒ½æ˜¯å¯¹è±¡
- **åæœ**: å‰ç«¯æ˜¾ç¤º `[object Object]`

```typescript
// å½“å‰çš„ç»“è®ºè§£æä»£ç ï¼ˆè¡Œ198-216ï¼‰
let tableConclusions: string[][] = [];
let parsedAny = tryParse(conclRaw);
if (!parsedAny){
  const m = (conclRaw||'').match(/\[[\s\S]*\]/);
  if (m) parsedAny = tryParse(m[0]);
}
if (parsedAny){
  // âš ï¸ é—®é¢˜ï¼šæ²¡æœ‰éªŒè¯ arr ä¸­çš„æ¯ä¸ªå…ƒç´ æ˜¯å¦ä¸ºå­—ç¬¦ä¸²
  tableConclusions = parsedAny.map((arr: any) =>
    (Array.isArray(arr) ? arr.map((v: any) => decodeEscapes(String(v))) : [])
  );
}
```

---

## æ”¹è¿›æ–¹æ¡ˆ

### æ–¹æ¡ˆ 1: å¢å¼ºè¡¨æ ¼è¯†åˆ«é€»è¾‘

```typescript
function extractPipeTables(md: string): string[] {
  const lines = md.split(/\r?\n/);
  const tables: string[] = [];
  let buf: string[] = [];
  let inTable = false;

  for (const line of lines) {
    const trimmed = line.trim();

    // æ›´ä¸¥æ ¼çš„è¡¨æ ¼è¡Œåˆ¤æ–­
    const isPipe = /^\|.*\|$/.test(trimmed) && trimmed.length > 2;

    // æ’é™¤ä»£ç å—å’Œç‰¹æ®Šæƒ…å†µ
    const isCodeBlock = /^```/.test(trimmed);
    const isMathFormula = /P\(.*\|.*\)/.test(trimmed);
    const isSinglePipe = (trimmed.match(/\|/g) || []).length === 1;

    if (isPipe && !isCodeBlock && !isMathFormula && !isSinglePipe) {
      if (!inTable) {
        buf = [trimmed];
        inTable = true;
      } else {
        buf.push(trimmed);
      }
    } else {
      if (inTable) {
        // éªŒè¯è¡¨æ ¼ç»“æ„
        if (isValidTable(buf)) {
          tables.push(buf.join("\n"));
        }
        buf = [];
        inTable = false;
      }
    }
  }

  // å¤„ç†æœ«å°¾çš„è¡¨æ ¼
  if (inTable && isValidTable(buf)) {
    tables.push(buf.join("\n"));
  }

  return tables;
}

// æ–°å¢ï¼šè¡¨æ ¼éªŒè¯å‡½æ•°
function isValidTable(lines: string[]): boolean {
  if (lines.length < 3) return false;  // è‡³å°‘ï¼šè¡¨å¤´ + åˆ†éš”ç¬¦ + 1æ•°æ®è¡Œ

  // éªŒè¯ç¬¬äºŒè¡Œæ˜¯åˆ†éš”ç¬¦
  if (!/^\|\s*:?-{2,}/.test(lines[1])) return false;

  // æå–åˆ—æ•°
  const headerCols = (lines[0].match(/\|/g) || []).length - 1;
  if (headerCols < 2) return false;  // è‡³å°‘2åˆ—

  // éªŒè¯æ¯è¡Œåˆ—æ•°ä¸€è‡´ï¼ˆå…è®¸Â±1è¯¯å·®ï¼‰
  for (let i = 2; i < lines.length; i++) {
    const cols = (lines[i].match(/\|/g) || []).length - 1;
    if (Math.abs(cols - headerCols) > 1) return false;
  }

  // éªŒè¯æ•°æ®è¡Œæ•°é‡
  const dataRows = lines.length - 2;
  if (dataRows < 1 || dataRows > 100) return false;  // è‡³å°‘1è¡Œï¼Œæœ€å¤š100è¡Œ

  return true;
}
```

### æ–¹æ¡ˆ 2: ä¿®å¤ç»“è®ºè§£æ

```typescript
// å¢å¼ºçš„ç»“è®ºè§£æ
let tableConclusions: string[][] = [];

const tryParse = (txt: string) => {
  try {
    const parsed = JSON.parse(txt);
    return Array.isArray(parsed) ? parsed : null;
  } catch { return null; }
};

let parsedAny = tryParse(conclRaw);
if (!parsedAny) {
  const m = (conclRaw || '').match(/\[[\s\S]*\]/);
  if (m) parsedAny = tryParse(m[0]);
}

if (parsedAny) {
  tableConclusions = parsedAny.map((item: any) => {
    // æƒ…å†µ1ï¼šå·²ç»æ˜¯å­—ç¬¦ä¸²æ•°ç»„
    if (Array.isArray(item)) {
      return item.map((v: any) => {
        if (typeof v === 'string') return decodeEscapes(v);
        if (typeof v === 'object' && v !== null) {
          // ä»å¯¹è±¡ä¸­æå–æ–‡æœ¬
          return decodeEscapes(v.text || v.conclusion || JSON.stringify(v));
        }
        return decodeEscapes(String(v));
      });
    }

    // æƒ…å†µ2ï¼šå•ä¸ªå­—ç¬¦ä¸²
    if (typeof item === 'string') {
      return [decodeEscapes(item)];
    }

    // æƒ…å†µ3ï¼šå¯¹è±¡
    if (typeof item === 'object' && item !== null) {
      const text = item.text || item.conclusion || item.summary;
      if (text) return [decodeEscapes(String(text))];

      // å°è¯•æå–æ‰€æœ‰å­—ç¬¦ä¸²å€¼
      const values = Object.values(item).filter(v => typeof v === 'string');
      if (values.length > 0) {
        return values.map(v => decodeEscapes(String(v)));
      }
    }

    // é»˜è®¤ï¼šè½¬ä¸ºå­—ç¬¦ä¸²
    return [decodeEscapes(String(item))];
  });
}

// ç¡®ä¿é•¿åº¦åŒ¹é…
if (tableConclusions.length !== tablesMd.length) {
  tableConclusions = tablesMd.map(() => ["æš‚æ— ç»“è®º"]);
}
```

### æ–¹æ¡ˆ 3: æ·»åŠ è°ƒè¯•æ—¥å¿—

```typescript
export async function POST(req: NextRequest) {
  try {
    // ... ç°æœ‰ä»£ç  ...

    const markdown = await llamaparseUploadAndGetMarkdown(file);
    console.log('[ingest] Markdown é•¿åº¦:', markdown.length);

    const tablesMd = extractPipeTables(markdown);
    console.log('[ingest] æå–åˆ°', tablesMd.length, 'ä¸ªè¡¨æ ¼');

    // æ‰“å°æ¯ä¸ªè¡¨æ ¼çš„å‰3è¡Œï¼ˆé¢„è§ˆï¼‰
    tablesMd.forEach((t, i) => {
      const preview = t.split('\n').slice(0, 3).join('\n');
      console.log(`[ingest] è¡¨æ ¼${i+1}é¢„è§ˆ:\n${preview}`);
    });

    const tableSchemas = tablesMd.map((t) => parsePipeTable(t).headers);
    console.log('[ingest] è¡¨æ ¼åˆ—æ•°:', tableSchemas.map(s => s.length));

    // ... ç»“è®ºæå– ...

    console.log('[ingest] ç»“è®ºåŸå§‹å“åº”ç±»å‹:', typeof conclRaw);
    console.log('[ingest] è§£æåç»“è®ºæ•°é‡:', tableConclusions.length);
    tableConclusions.forEach((cons, i) => {
      console.log(`[ingest] è¡¨æ ¼${i+1}ç»“è®º:`, cons);
    });

    // ... è¿”å›ç»“æœ ...
  } catch (e: any) {
    console.error("[ingest] é”™è¯¯:", e);
    return NextResponse.json({ error: String(e?.message || e) }, { status: 500 });
  }
}
```

---

## æµ‹è¯•å»ºè®®

### æµ‹è¯•ç”¨ä¾‹ 1: æ­£å¸¸è¡¨æ ¼
```markdown
| Region | Value |
|--------|-------|
| North  | 100   |
| South  | 200   |
```
**æœŸæœ›**: æ­£ç¡®è¯†åˆ«ä¸º1ä¸ªè¡¨æ ¼

### æµ‹è¯•ç”¨ä¾‹ 2: ä»£ç å—ä¸­çš„ç®¡é“ç¬¦
```markdown
Run this command:
```bash
cat file.txt | grep pattern
```
```
**æœŸæœ›**: ä¸è¯†åˆ«ä¸ºè¡¨æ ¼

### æµ‹è¯•ç”¨ä¾‹ 3: æ•°å­¦å…¬å¼
```markdown
The probability P(A|B) = 0.5
```
**æœŸæœ›**: ä¸è¯†åˆ«ä¸ºè¡¨æ ¼

### æµ‹è¯•ç”¨ä¾‹ 4: åˆ—æ•°ä¸ä¸€è‡´
```markdown
| A | B | C |
|---|---|
| 1 | 2 | 3 |
```
**æœŸæœ›**: ä¸è¯†åˆ«ä¸ºè¡¨æ ¼ï¼ˆåˆ†éš”ç¬¦åˆ—æ•°ä¸åŒ¹é…ï¼‰

### æµ‹è¯•ç”¨ä¾‹ 5: åªæœ‰è¡¨å¤´
```markdown
| A | B |
|---|---|
```
**æœŸæœ›**: ä¸è¯†åˆ«ä¸ºè¡¨æ ¼ï¼ˆæ— æ•°æ®è¡Œï¼‰

---

## å®æ–½æ­¥éª¤

1. âœ… å…ˆå¤‡ä»½ç°æœ‰ä»£ç 
2. âœ… å®ç°å¢å¼ºçš„ `isValidTable()` å‡½æ•°
3. âœ… æ›´æ–° `extractPipeTables()` ä½¿ç”¨æ–°éªŒè¯
4. âœ… ä¿®å¤ç»“è®ºè§£æé€»è¾‘
5. âœ… æ·»åŠ è¯¦ç»†çš„è°ƒè¯•æ—¥å¿—
6. âœ… æµ‹è¯•å„ç§è¾¹ç•Œæƒ…å†µ
7. âœ… ç›‘æ§ç”Ÿäº§ç¯å¢ƒæ—¥å¿—

---

## é¢„æœŸæ•ˆæœ

- âœ… å‡å°‘è¯¯è¯†åˆ«ç‡ > 80%
- âœ… ç»“è®ºæ˜¾ç¤ºæ­£å¸¸ç‡ = 100%
- âœ… ä¿æŒçœŸå®è¡¨æ ¼è¯†åˆ«ç‡ > 95%
- âœ… æä¾›æ¸…æ™°çš„è°ƒè¯•ä¿¡æ¯
