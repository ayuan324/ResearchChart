# 表格解析问题分析

## 当前解析逻辑（`/api/ingest/route.ts`）

### 1. 表格提取函数 `extractPipeTables()`

```typescript
function extractPipeTables(md: string): string[] {
  const lines = md.split(/\r?\n/);
  const tables: string[] = [];
  let buf: string[] = [];
  let inTable = false;

  for (const line of lines) {
    const isPipe = /\|/.test(line);  // ⚠️ 问题1：只要有 | 就认为是表格行
    if (isPipe) {
      inTable = true;
      buf.push(line);
    } else {
      if (inTable) {
        // 只检查第二行是否有分隔符
        if (buf.length >= 2 && /\|\s*-{2,}\s*\|/.test(buf[1])) {
          tables.push(buf.join("\n"));
        }
        buf = [];
        inTable = false;
      }
    }
  }

  if (inTable && buf.length >= 2 && /\|\s*-{2,}\s*\|/.test(buf[1])) {
    tables.push(buf.join("\n"));
  }

  return tables;
}
```

### 🐛 问题分析

#### 问题 1: 过度宽松的表格识别
- **现象**: 只要一行包含 `|` 字符，就被认为是表格行
- **后果**: 会将以下内容误识别为表格：
  - 代码块中的管道符：`command | grep pattern`
  - 数学公式：`P(A|B) = 0.5`
  - 普通文本：`选项A | 选项B`
  - 引用块中的竖线

#### 问题 2: 缺少表格结构验证
- **现象**: 只验证第二行是否是分隔符，不验证整体结构
- **后果**:
  - 不检查列数是否一致
  - 不检查是否有足够的数据行
  - 不检查表头是否合理

#### 问题 3: 结论解析不稳定
- **现象**: `table_conclusions` 返回的可能是嵌套数组，也可能是对象
- **后果**: 前端显示 `[object Object]`

```typescript
// 当前的结论解析代码（行198-216）
let tableConclusions: string[][] = [];
let parsedAny = tryParse(conclRaw);
if (!parsedAny){
  const m = (conclRaw||'').match(/\[[\s\S]*\]/);
  if (m) parsedAny = tryParse(m[0]);
}
if (parsedAny){
  // ⚠️ 问题：没有验证 arr 中的每个元素是否为字符串
  tableConclusions = parsedAny.map((arr: any) =>
    (Array.isArray(arr) ? arr.map((v: any) => decodeEscapes(String(v))) : [])
  );
}
```

---

## 改进方案

### 方案 1: 增强表格识别逻辑

```typescript
function extractPipeTables(md: string): string[] {
  const lines = md.split(/\r?\n/);
  const tables: string[] = [];
  let buf: string[] = [];
  let inTable = false;

  for (const line of lines) {
    const trimmed = line.trim();

    // 更严格的表格行判断
    const isPipe = /^\|.*\|$/.test(trimmed) && trimmed.length > 2;

    // 排除代码块和特殊情况
    const isCodeBlock = /^```/.test(trimmed);
    const isMathFormula = /P\(.*\|.*\)/.test(trimmed);
    const isSinglePipe = (trimmed.match(/\|/g) || []).length === 1;

    if (isPipe && !isCodeBlock && !isMathFormula && !isSinglePipe) {
      if (!inTable) {
        buf = [trimmed];
        inTable = true;
      } else {
        buf.push(trimmed);
      }
    } else {
      if (inTable) {
        // 验证表格结构
        if (isValidTable(buf)) {
          tables.push(buf.join("\n"));
        }
        buf = [];
        inTable = false;
      }
    }
  }

  // 处理末尾的表格
  if (inTable && isValidTable(buf)) {
    tables.push(buf.join("\n"));
  }

  return tables;
}

// 新增：表格验证函数
function isValidTable(lines: string[]): boolean {
  if (lines.length < 3) return false;  // 至少：表头 + 分隔符 + 1数据行

  // 验证第二行是分隔符
  if (!/^\|\s*:?-{2,}/.test(lines[1])) return false;

  // 提取列数
  const headerCols = (lines[0].match(/\|/g) || []).length - 1;
  if (headerCols < 2) return false;  // 至少2列

  // 验证每行列数一致（允许±1误差）
  for (let i = 2; i < lines.length; i++) {
    const cols = (lines[i].match(/\|/g) || []).length - 1;
    if (Math.abs(cols - headerCols) > 1) return false;
  }

  // 验证数据行数量
  const dataRows = lines.length - 2;
  if (dataRows < 1 || dataRows > 100) return false;  // 至少1行，最多100行

  return true;
}
```

### 方案 2: 修复结论解析

```typescript
// 增强的结论解析
let tableConclusions: string[][] = [];

const tryParse = (txt: string) => {
  try {
    const parsed = JSON.parse(txt);
    return Array.isArray(parsed) ? parsed : null;
  } catch { return null; }
};

let parsedAny = tryParse(conclRaw);
if (!parsedAny) {
  const m = (conclRaw || '').match(/\[[\s\S]*\]/);
  if (m) parsedAny = tryParse(m[0]);
}

if (parsedAny) {
  tableConclusions = parsedAny.map((item: any) => {
    // 情况1：已经是字符串数组
    if (Array.isArray(item)) {
      return item.map((v: any) => {
        if (typeof v === 'string') return decodeEscapes(v);
        if (typeof v === 'object' && v !== null) {
          // 从对象中提取文本
          return decodeEscapes(v.text || v.conclusion || JSON.stringify(v));
        }
        return decodeEscapes(String(v));
      });
    }

    // 情况2：单个字符串
    if (typeof item === 'string') {
      return [decodeEscapes(item)];
    }

    // 情况3：对象
    if (typeof item === 'object' && item !== null) {
      const text = item.text || item.conclusion || item.summary;
      if (text) return [decodeEscapes(String(text))];

      // 尝试提取所有字符串值
      const values = Object.values(item).filter(v => typeof v === 'string');
      if (values.length > 0) {
        return values.map(v => decodeEscapes(String(v)));
      }
    }

    // 默认：转为字符串
    return [decodeEscapes(String(item))];
  });
}

// 确保长度匹配
if (tableConclusions.length !== tablesMd.length) {
  tableConclusions = tablesMd.map(() => ["暂无结论"]);
}
```

### 方案 3: 添加调试日志

```typescript
export async function POST(req: NextRequest) {
  try {
    // ... 现有代码 ...

    const markdown = await llamaparseUploadAndGetMarkdown(file);
    console.log('[ingest] Markdown 长度:', markdown.length);

    const tablesMd = extractPipeTables(markdown);
    console.log('[ingest] 提取到', tablesMd.length, '个表格');

    // 打印每个表格的前3行（预览）
    tablesMd.forEach((t, i) => {
      const preview = t.split('\n').slice(0, 3).join('\n');
      console.log(`[ingest] 表格${i+1}预览:\n${preview}`);
    });

    const tableSchemas = tablesMd.map((t) => parsePipeTable(t).headers);
    console.log('[ingest] 表格列数:', tableSchemas.map(s => s.length));

    // ... 结论提取 ...

    console.log('[ingest] 结论原始响应类型:', typeof conclRaw);
    console.log('[ingest] 解析后结论数量:', tableConclusions.length);
    tableConclusions.forEach((cons, i) => {
      console.log(`[ingest] 表格${i+1}结论:`, cons);
    });

    // ... 返回结果 ...
  } catch (e: any) {
    console.error("[ingest] 错误:", e);
    return NextResponse.json({ error: String(e?.message || e) }, { status: 500 });
  }
}
```

---

## 测试建议

### 测试用例 1: 正常表格
```markdown
| Region | Value |
|--------|-------|
| North  | 100   |
| South  | 200   |
```
**期望**: 正确识别为1个表格

### 测试用例 2: 代码块中的管道符
```markdown
Run this command:
```bash
cat file.txt | grep pattern
```
```
**期望**: 不识别为表格

### 测试用例 3: 数学公式
```markdown
The probability P(A|B) = 0.5
```
**期望**: 不识别为表格

### 测试用例 4: 列数不一致
```markdown
| A | B | C |
|---|---|
| 1 | 2 | 3 |
```
**期望**: 不识别为表格（分隔符列数不匹配）

### 测试用例 5: 只有表头
```markdown
| A | B |
|---|---|
```
**期望**: 不识别为表格（无数据行）

---

## 实施步骤

1. ✅ 先备份现有代码
2. ✅ 实现增强的 `isValidTable()` 函数
3. ✅ 更新 `extractPipeTables()` 使用新验证
4. ✅ 修复结论解析逻辑
5. ✅ 添加详细的调试日志
6. ✅ 测试各种边界情况
7. ✅ 监控生产环境日志

---

## 预期效果

- ✅ 减少误识别率 > 80%
- ✅ 结论显示正常率 = 100%
- ✅ 保持真实表格识别率 > 95%
- ✅ 提供清晰的调试信息
